drawing the wave with a single obj

// ------NOTE: MANAGE THE HEAP MEMORY IN OBJECTS.C FOR GENERATING OPJECTS


#include "context.h"
#include "objects.h"
#include <string.h>

#define NUM_OF_CIRCLES 1
#define NUM_OF_LINES 100
float time=0;
struct Object circles[NUM_OF_CIRCLES];
struct Object circleLines[NUM_OF_CIRCLES];

struct Vertex waveVertices[NUM_OF_LINES+1];

int
main(int argc, char **argv){
  // Setup context
  if(!initContext()) return -1;  

  // ---------SHADER------------
  // global shader
  char *verSrc  = "../src/defaultVertexShader.glsl";
  char *fragSrc = "../src/defaultFragShader.glsl";
  struct ShaderProgram shader;
  generateShaderProgramVF(&shader, verSrc, fragSrc);
  
  // --------OBJECTS-----------
  for(int i=0;i<NUM_OF_CIRCLES;i++){
    int n = i*2+1;
    
    generatePolygon(&circles[i], 90, DRAW_LINE_STRIP);
    float radius = 100.f*(4/(n*M_PI));
    scale(&circles[i]._transform, (vec3){radius, radius, 0});
    
    // Circle line
    generateLine(&circleLines[i]);
    translate(&circleLines[i]._transform, circles[i]._transform._location);
    scale(&circleLines[i]._transform, (vec3){radius, radius, 1.f});
  }

 
  struct Object wave;
  generatePolygon(&wave, NUM_OF_LINES+1, GL_LINE_LOOP);
  translate(&wave._transform, (vec3){500.f, HEIGHT/2, -1});

  // circleLine to wave
  struct Object waveLine;
  generateLine(&waveLine);
  scale(&waveLine._transform, (vec3){1.f, 1.f, 1.f});

  int waveParticle=0;
  while(!contextShouldClose()){
    clearContext();
    
    if(waveParticle==NUM_OF_LINES+1) waveParticle=0;

    time+=40*delta;// fake time but to make it fast.Note faster mean less efficiency 
    // -----------DRAW----------s
    // Big circle
    float x, y;
    x=300;y=HEIGHT/2;

    for(int i=0;i<NUM_OF_CIRCLES;i++){
      int n=i*2+1;

      // Circle
      translate(&circles[i]._transform, (vec3){x, y, -1});
      drawPolygon(&circles[i], &shader);      
      
      // Line
      vec2 startPoint;
      vec2 endPoint;
      startPoint[0] = cos(n*time);
      startPoint[1] = sin(n*time);
      endPoint[0] = 0;
      endPoint[1] = 0;
      struct Vertex all[2]={{startPoint[0], startPoint[1], -1.f},
      			  {endPoint[0], endPoint[1], -1.f}};
      resendBufferData(&circleLines[i]._vbo, all, 2, 0);
      translate(&circleLines[i]._transform, circles[i]._transform._location);
      drawPolygon(&circleLines[i], &shader);

      float radius = 100.f*(4/(n*M_PI));
      x = circles[i]._transform._location[0]+radius*cos(n*time);
      y = circles[i]._transform._location[1]+radius*sin(n*time);
    }
    


    

    waveVertices[waveParticle] = (struct Vertex){0.f, y-(HEIGHT/2), 0.f};

    for(int i=0;i<NUM_OF_LINES+1;i++){
      if(i==waveParticle)continue;
  
      wave._data._vertices[i].x+=10;
      
      wave._data._vertices[i].y=waveVertices[i].y;
      waveVertices[i]=(struct Vertex){wave._data._vertices[i].x,wave._data._vertices[i].y,0.f};
    }
   

    changeVertices(&wave, waveVertices, NUM_OF_LINES+1);
    drawPolygon(&wave, &shader);

    





    
    // wave line
    translate(&waveLine._transform, (vec3){x, y, -1.f});
    float dist = 500 - x;
    struct Vertex all2={dist, y, -1.f};
    updateVertices(&waveLine, &all2, 1);
    //drawPolygon(&waveLine, &shader);
    
    waveParticle++;    
    updateContext();
  }
  // free data
  cleanContext();
  return 0;
}
