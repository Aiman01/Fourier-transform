// ------NOTE: MANAGE THE HEAP MEMORY IN OBJECTS.C FOR GENERATING OPJECTS

#include "context.h"
#include "objects.h"
#include <string.h>

#define NUM_OF_CIRCLES 5
#define NUM_OF_LINES 1000
struct Object circles[NUM_OF_CIRCLES];
struct Object circleLines[NUM_OF_CIRCLES];
float waveVerticesY[NUM_OF_LINES];
float squareWaveVerticesY[]={100.f, 100.f, 100.f, -100.f, -100.f, -100.f, 100.f, 100.f, 100.f, -100.f, -100.f, -100.f, 100.f, 100.f, 100.f, -100.f, -100.f, -100.f};
float time=0;

int
main(int argc, char **argv){
  // Setup context
  if(!initContext()) return -1;  

  // ---------SHADER------------
  // global shader
  char *verSrc  = "../src/defaultVertexShader.glsl";
  char *fragSrc = "../src/defaultFragShader.glsl";
  char *geoSrc  = "../src/defaultGeoShader.glsl";
  char *circleFragSrc = "../src/circleFragShader.glsl";
  
  struct ShaderProgram lineShader, waveShader, circleShader;
  generateShaderProgramVF(&circleShader, verSrc, circleFragSrc);
  generateShaderProgramVF(&lineShader, verSrc, fragSrc);
  generateShaderProgramVFG(&waveShader, verSrc, fragSrc, geoSrc);
  setInt(&waveShader, "numOfLines", NUM_OF_LINES);
  // --------OBJECTS-----------
  for(int i=0;i<NUM_OF_CIRCLES;i++){
    int n = i*2+1;
    generatePolygon(&circles[i], 90, DRAW_LINE_STRIP);
    float radius = 100.f*(4/(n*M_PI));
    scale(&circles[i]._transform, (vec3){radius, radius, 0});
    // Circle line
    generateLine(&circleLines[i]);
    translate(&circleLines[i]._transform, circles[i]._transform._location);
    scale(&circleLines[i]._transform, (vec3){radius, radius, 1.f});
  }

  // wave
  struct Object wave;
  generatePoint(&wave);
  translate(&wave._transform, (vec3){500, HEIGHT/2, -1});
  
  // circleLine to wave
  struct Object waveLine;
  generateLine(&waveLine);
  scale(&waveLine._transform, (vec3){1.f, 1.f, 1.f});

  while(!contextShouldClose()){
    if(isKeyPress(KEY(SPACE))){
      clearContext();
      time+=.005f;// fake time but to make it fast.Note faster mean less efficiency
      int move=0;
      // -----------DRAW----------s
      // Big circle
      float x, y;
      x=300;y=HEIGHT/2;
      for(int i=0;i<NUM_OF_CIRCLES;i++){
	int n=i*2+1;
	// Circle
	translate(&circles[i]._transform, (vec3){x, y, -1});
	drawPolygon(&circles[i], &circleShader);      
	// Line
	vec2 startPoint;
	vec2 endPoint;
	startPoint[ 0] = cos(n*time);
	startPoint[1] = sin(n*time);
	endPoint[0] = 0;
	endPoint[1] = 0;
	struct Vertex all[2]={{startPoint[0], startPoint[1], -1.f},
			      {endPoint[0], endPoint[1], -1.f}};
	resendBufferData(&circleLines[i]._vbo, all, 2, 0);
	translate(&circleLines[i]._transform, circles[i]._transform._location);
	drawPolygon(&circleLines[i], &lineShader);
	float radius = 100.f*(4/(n*M_PI));
	x = circles[i]._transform._location[0]+radius*cos(n*time);
	y = circles[i]._transform._location[1]+radius*sin(n*time);
      }

      // Wave
      char vertex[32];
      float temp1 =0;
      for(int i=0;i<=NUM_OF_LINES;i++){
	if(i==0){
	  setFloat(&waveShader, "verticesY[0]", 2*(y/HEIGHT)-1);
	  waveVerticesY[0]=y, temp1=y, i++;
	}
	float temp2=waveVerticesY[i];
	waveVerticesY[i]=temp1;
	temp1=temp2;
	sprintf(vertex, "verticesY[%i]", i);
	setFloat(&waveShader, vertex, 2*(waveVerticesY[i]/HEIGHT)-1);
      }
      drawPolygon(&wave, &waveShader);

    
      // wave line
      translate(&waveLine._transform, (vec3){x, y, -1.f});
      float dist = 500 - x;
      struct Vertex all2[]={{0.f, 0.f, 0.f},{dist, y-(waveLine._transform._location[1]), 0.f}};
      changeVertices(&waveLine, all2, 2);
      drawPolygon(&waveLine, &lineShader);
    }
    updateContext();
  }
  // free data
  cleanContext();
  return 0;
}
