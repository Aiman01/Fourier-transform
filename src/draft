#include "context.h"
#include "objects.h"
#include <string.h>

#define NUM_OF_CIRCLES 3
float time=0;
struct Object circles[NUM_OF_CIRCLES];
struct Object circleLines[NUM_OF_CIRCLES];

int
main(int argc, char **argv){
  // Setup context
  if(!initContext()) return -1;  

  // ---------SHADER------------
  // global shader
  char *verSrc  = "../src/defaultVertexShader.glsl";
  char *fragSrc = "../src/defaultFragShader.glsl";
  struct ShaderProgram shader;
  generateShaderProgramVF(&shader, verSrc, fragSrc);
  
  // --------OBJECTS-----------
  for(int i=0;i<NUM_OF_CIRCLES;i++){
    int n = i*2+1;
    
    generatePolygon(&circles[i], 90, DRAW_LINE_STRIP);
    float radius = 100.f*(4/(n*M_PI));
    scale(&circles[i]._transform, (vec3){radius, radius, 0});
    
    // Circle line
    generateLine(&circleLines[i]);
    translate(&circleLines[i]._transform, circles[i]._transform._location);
    scale(&circleLines[i]._transform, (vec3){radius, radius, 1.f});
  }

  // wave
  struct Object wave[1000];
  for(int i=0;i<1000;i++){
    generateLine(&wave[i]);
  }
  
  // line to wave
  struct Object waveLine;
  generateLine(&waveLine);
  scale(&waveLine._transform, (vec3){1.f, 1.f, 1.f});

  int waveParticle=0;
  while(!contextShouldClose()){
    clearContext();
    if(waveParticle==1000) waveParticle=0;

    time+=1*delta;// fake time but to make it fast.Note faster mean less efficiency 
    // -----------DRAW----------s
    // Big circle
    float x, y;
    x=300;y=HEIGHT/2;
    for(int i=0;i<NUM_OF_CIRCLES;i++){
      int n=i*2+1;

      // Circle
      translate(&circles[i]._transform, (vec3){x, y, -1});
      drawPolygon(&circles[i], &shader);      
      
      // Line
      vec2 startPoint;
      vec2 endPoint;
      startPoint[0] = cos(n*time);
      startPoint[1] = sin(n*time);
      endPoint[0] = 0;
      endPoint[1] = 0;
      struct Vertex all[2]={{startPoint[0], startPoint[1], -1.f},
      			  {endPoint[0], endPoint[1], -1.f}};
      resendBufferData(&circleLines[i]._vbo, all, 2, 0);
      translate(&circleLines[i]._transform, circles[i]._transform._location);
      drawPolygon(&circleLines[i], &shader);

      float radius = 100.f*(4/(n*M_PI));
      x = circles[i]._transform._location[0]+radius*cos(n*time);
      y = circles[i]._transform._location[1]+radius*sin(n*time);
    }

    // wave 
    translate(&wave[waveParticle]._transform, (vec3){500, y, -1});
    for(int i=0;i<1000;i++){
      translate(&wave[i]._transform, (vec3){wave[i]._transform._location[0]+3, wave[i]._transform._location[1], -1});
      drawPolygon(&wave[i], &shader);
    }
    
    // wave line
    translate(&waveLine._transform, (vec3){x, y, -1.f});
    float dist = 500 - x;
    struct Vertex all2={dist, y, -1.f};
    resendBufferData(&waveLine._vbo, &all2, 1, 0);
    drawPolygon(&waveLine, &shader);
    
    waveParticle++;    
    updateContext();
  }
  // free data
  cleanContext();
  return 0;
}
